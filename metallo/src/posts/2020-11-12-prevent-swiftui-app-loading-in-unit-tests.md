---
title: How to bypass the SwiftUI App when running unit tests
description: "How to make the unit tests of your SwiftUI app safer and faster by preventing them from running the program startup flow. This will avoid all of the launch operations like network requests or reads from the local storage that would affect the global state."
tags:
- Swift
- SwiftUI
- Xcode
- Testing
og_title: How to skip the SwiftUI App when running unit tests
og_description: "Bypass the App launch to detach your unit tests from global state."
og_image: https://s3.amazonaws.com/mokacoding/2020-11-12-swiftui-skip-app.jpg
---

When an app launches, it kicks off setup operations like asking the remote API for new data, loading information from the local storage, or checking-in with analytics providers.

All this work gives the user a smooth startup experience but is unnecessary when running the unit tests and dangerous too: it can meddle with the global state, resulting in hard to diagnose failures.
Sometimes, it can even make the tests noticeably slower or log noise into your analytics.

One of the first things I do when taking up a new project, whether greenfield or established, is **preventing the unit tests from running the app startup flow**.

I published a post about this [back in 2016](https://mokacoding.com/blog/prevent-unit-tests-from-loading-app-delegate-in-swift/), when UIKit was the only framework in town.
It's now time to revisit it for SwiftUI based applications.

## SwiftUI `App`

```swift
// AppLauncher.swift
import SwiftUI

@main
struct AppLauncher {

    static func main() throws {
        if NSClassFromString("XCTestCase") == nil {
            MyAwesomeApp.main()
        } else {
            TestApp.main()
        }
    }
}

struct TestApp: App {

    var body: some Scene {
        WindowGroup { Text("Running Unit Tests") }
    }
}

// MyAwesomeApp.swift
import SwiftUI

struct MyAwesomeApp: App {

    var body: some Scene { ... }
}
```

_You can find the source code for this example [on GitHub](https://github.com/mokacoding/TestAppDelegateExample)_.

Let's unpack what the code does.
First of all, the top-level entry point for the program flow, marked by the [`@main` attribute](https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID626) is `AppLauncher`.
That's different from the default code generated by Xcode, where `MyAwesomeApp` would have been the entry point.
This dedicated launcher allows us to differentiated between tests and genuine runs of the app.

To support the `@main`, `AppLauncher` must provide a static `main` method that the OS will call when launching the executable.

_Checkout [Keith Harrison](https://twitter.com/kharrison)'s post "[What does `@main` do in Swift 5.3](https://useyourloaf.com/blog/what-does-main-do-in-swift-5.3/)" for a deep dive into how the app launches._

`AppLauncher` controls whether we're running the unit tests using the availability of the `XCTestCase` class as a proxy.
If the class is found, the XCTest framework is loaded, which means the app launched as the host of the tests target.

Finally, if `AppLauncher` determines that the tests are running, it returns a dummy `App` implementation.

## SwiftUI with UIKit App Delegate

If you are mix-and-matching SwiftUI and UIKit, that is, if you have an app with SwiftUI interface and "UIKit App Delegate" life cycle, then you can use the same approach [as a UIKit only app](https://mokacoding.com/blog/prevent-unit-tests-from-loading-app-delegate-in-swift/).

```swift
// main.swift
import UIKit

private func delegateClassName() -> String? {
  if NSClassFromString("XCTestCase") == nil {
    NSStringFromClass(AppDelegate.self)
  } else {
    return nil
  }
}

UIApplicationMain(
  CommandLine.argc,
  CommandLine.unsafeArgv,
  nil,
  delegateClassName()
)

// AppDelegate.swift
import UIKit

class AppDelegate: UIResponder, UIApplicationDelegate {
  // ...
}
```

_This example is also available [on GitHub](https://github.com/mokacoding/TestAppDelegateExample)_.

Another option is to use an `AppLauncher` returning a different `UIApplicationDelegate` implementation for the tests, like in the SwiftUI only case.
I find this approach with a dedicated `main.swift` file easier to discover, and I like how there is no need for a dummy app delegate when running the tests.

---

I hope you'll find this technique useful.
If you have any questions or need help adopting this approach in your codebase, leave a comment below or get in touch on Twitter at [@mokagio](https://twitter.com/mokagio).
