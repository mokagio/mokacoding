<!DOCTYPE html><html lang="en"><head><title>How to TDD in Swift, a step by step guide | mokacoding</title><meta name="description" content="With test driven development you can write high quality software in small shippable steps. Here's how to get started."><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1"><!-- Canonical URL--><link rel="canonical" href="https://mokacoding.com/blog/step-by-step-tdd-in-swift-part-1/"><!-- Open Graph meta tags--><meta property="og:title" content="How to TDD in Swift, a step by step guide"><meta property="og:description" content="With test driven development you can write high quality software in small shippable steps. Here's how to get started."><meta property="og:url" content="/"><meta property="og:type" content="article"><meta property="og:site_name" content="mokacoding"><meta property="og:image" content="https://s3.amazonaws.com/mokacoding/2019-02-08-test-succeded.jpg"><!-- Twitter meta tags--><meta property="twitter:card" content="summary"><meta property="twitter:site" content="@mokacoding"><meta property="twitter:creator" content="@mokagio"><!-- Stylesheets--><link href="/css/griddy.css" rel="stylesheet"><link href="/css/style.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/zenburn.css" rel="stylesheet"><!-- FavIcon--><!-- Thanks to https://www.favicon-generator.org/ & https://html2jade.org/--><link rel="apple-touch-icon" sizes="57x57" href="https://s3.amazonaws.com/mokacoding/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="https://s3.amazonaws.com/mokacoding/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="https://s3.amazonaws.com/mokacoding/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="https://s3.amazonaws.com/mokacoding/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="https://s3.amazonaws.com/mokacoding/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="https://s3.amazonaws.com/mokacoding/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="https://s3.amazonaws.com/mokacoding/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="https://s3.amazonaws.com/mokacoding/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="https://s3.amazonaws.com/mokacoding/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="https://s3.amazonaws.com/mokacoding/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="https://s3.amazonaws.com/mokacoding/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="https://s3.amazonaws.com/mokacoding/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="https://s3.amazonaws.com/mokacoding/favicon-16x16.png"><link rel="manifest" href="https://s3.amazonaws.com/mokacoding/manifest.json"><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="https://s3.amazonaws.com/mokacoding/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><!-- SumoMe--><script src="//load.sumome.com/" data-sumo-site-id="dd80959300db03e20c8bc3dd899f1424fd764d261e6c3c41923c96482a270dba" async="async"></script></head><body><!-- Use this to render an extra header in special occasions--><div class="special-header"><div class="page"><div class="row-12"><div class="col-12"><p><p><a href="https://goo.gl/forms/lCLlJd9hqCUYoTME2">What is your biggest struggle right now with building software?</a></p>
</p></div></div></div></div><div class="page"><div class="row-12"><div class="col-12 header"><h1 class="brand"><a href="/">mokacoding</a></h1><div class="punchline">unit and acceptance testing, automation, productivity</div><div class="links"><a href="/archive.html">Archive</a><a href="/tags.html">Tags</a><a href="https://gio.codes">About</a><a href="#subscribe">Subscribe</a><a href="/feed.xml"><i class="fa fa-rss"></i></a></div></div><div class="col-12"><div class="post-container"><h2 class="post-title"><a href="/blog/step-by-step-tdd-in-swift-part-1">How to TDD in Swift, a step by step guide</a></h2><p class="post-meta"><span class="post-date">Fri Feb 08 2019&nbsp;</span><a href="/tag/TDD/index.html" class="post-tag">-TDD</a><a href="/tag/Swift/index.html" class="post-tag">-Swift</a></p><div class="post"><p>There is a way of writing software that minimizes the chances of bugs and unexpected behaviours creeping in. Developing this way also results in small easy to change components.</p>
<p>This way of writing software is Test Driven Development. This post show how to practice TDD, and how it makes for a pleasurable and effective coding experience.</p>
<hr>
<p>Giuseppe, the owner of you favourite pizza place, has hired you to build the iOS app for his business. Like the wise developer that you are you encourage Giuseppe to start small and iterate quickly. The two of you agree to start with a digital menu for his customers, to gauge its reception.</p>
<p>A way to move quickly in developing an app, while making sure it behaves as expected, is to detach its business logic from the details of the how inputs and outputs are sent to the users. <a href="https://blog.cleancoder.com/">Uncle Bob</a> illustrates the idea in <a href="https://www.youtube.com/watch?v=HhNIttd87xs">this talk</a> and in his book <a href="https://geni.us/dM1KXD8">Clean Architecture</a>.</p>
<p>We should consider iOS the <em>delivery layer</em> for our applications, keeping as little business logic implementation living at that level as possible. Imagine you were building a CLI app instead, then pretend iOS is a GUI wrapper around it. Ideally none of the business logic should ever <code>import UIKit</code>.</p>
<p>The question you should always ask yourself when TDDing is &quot;<strong>what&#39;s the smallest and simplest thing I can do?</strong>&quot;. What&#39;s the smallest thing we can build to start developing this app? Giuseppe&#39;s menu has three sections: pizzas, beverages, and desserts. Let&#39;s start with a menu app showing only the pizzas.</p>
<p>This version of the app with only pizzas is our <a href="http://wiki.c2.com/?WalkingSkeleton">walking skeleton</a>, an app with only the bare minimum of functionality to make sure all the components are glued together and working end to end.</p>
<p>Since the core of our business logic is the conversion of Giuseppe&#39;s menu to a format that can be displayed let&#39;s start with a component for it, let&#39;s call it <code>MenuDataSource</code>.</p>
<p><strong>When doing TDD we always start from the tests</strong>, so let&#39;s create one for <code>MenuDataSource</code>. In this post we&#39;ll use Apple&#39;s <a href="https://developer.apple.com/documentation/xctest"><code>XCTest</code> famework</a>, but that&#39;s not the only option to write tests in Swift.</p>
<pre><code class=" hljs swift"><span class="hljs-meta">@testable</span> <span class="hljs-keyword">import</span> Giuseppes
<span class="hljs-keyword">import</span> XCTest

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuDataSourceTests</span>: <span class="hljs-title">XCTestCase</span> </span>{
}
</code></pre>
<p>Our test should describe and verify the <strong>behaviour</strong> we want for <code>MenuDataSource</code>. We decided that our walking skeleton will have only pizzas, so let&#39;s make sure <code>MenuDataSource</code> provides only one section for the menu.</p>
<p>To test this behaviour we&#39;ll first need an instance of <code>MenuDataSource</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-meta">@testable</span> <span class="hljs-keyword">import</span> Giuseppes
<span class="hljs-keyword">import</span> XCTest

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuDataSourceTests</span>: <span class="hljs-title">XCTestCase</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
        <span class="hljs-comment">// 🔴 Use of unresolved identifier &#x27;MenuDataSource&#x27;;</span>
        <span class="hljs-comment">// did you mean &#x27;MenuDataSourceTests&#x27;?</span>
    }
}
</code></pre>
<p>The code is not compiling, as we haven&#39;t defined <code>MenuDataSource</code> yet. In TDD compilation failures count as test failures, and our job is to <strong>write the simplest code that we can to make the test pass</strong>, which in this case means compile.</p>
<p>To make the test compile we have to define <code>MenuDataSource</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuDataSource</span> </span>{ }
</code></pre>
<p>Notice that there are no properties or <code>init</code> parameters in this <code>MenuDataSource</code>. This is what means to write the simplest code possible, just enough code to make the test pass. We&#39;ll add properties to the type only as we&#39;ll need them to make the tests we&#39;ll write pass.</p>
<p>Now that the test is compiling let&#39;s move to asserting the behaviour of <code>MenuDataSource</code> when asked for sections.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>)
    <span class="hljs-comment">// 🔴 Value of type &#x27;MenuDataSource&#x27; has no member &#x27;numberOfSections&#x27;</span>
}
</code></pre>
<p>Once again we have a failing test due to a compilation error. What&#39;s the simplest code we can write to make it pass?</p>
<pre><code class=" hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuDataSource</span> </span>{

    <span class="hljs-keyword">let</span> numberOfSections = <span class="hljs-number">1</span>
}
</code></pre>
<p>Notice once again that there is no logic here, just an hardcoded value. This is enough to make our test compile and also pass, and we&#39;re happy with it.</p>
<pre><code class=" hljs swift"><span class="hljs-meta">@testable</span> <span class="hljs-keyword">import</span> Giuseppes
<span class="hljs-keyword">import</span> XCTest

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuDataSourceTests</span>: <span class="hljs-title">XCTestCase</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
        <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>)  <span class="hljs-comment">// ✅</span>
    }
}
</code></pre>
<p>A word of warning. <strong>You should never trust a test you haven&#39;t seen fail</strong>. We&#39;ve seen the test fail due to a compilation error, but what about testing the actual behaviour? It wouldn&#39;t hurt to change the hardcoded 1 in <code>MenuDataSource</code> to another value, and verify that the test fails.</p>
<p>We finally have a passing test, let&#39;s commit: <code>Implement MenuDataSource returning number of sections</code>.</p>
<p>What&#39;s next? Let&#39;s add a way to get the number of rows in a section.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), ???)
}
</code></pre>
<p>Hang on, how many rows should there be in a section? If our section is showing the pizzas then it should have as many rows as the pizzas to display. How can we test this behaviour? We need a way to control this input parameter, for example we can pass the array of pizzas to display to <code>MenuDataSource</code> at <code>init</code> time.</p>
<p><strong>The act of writing tests for the behaviours we want reveals the design details of our software</strong>. We didn&#39;t decide upfront that <code>MenuDataSource</code> should be initialized with an <code>Array&lt;Pizza&gt;</code>, we let the need for it <a href="https://en.wikipedia.org/wiki/Emergent_Design">emerge</a> from the tests.</p>
<p>Before solving that problem let&#39;s bring the test to a successful state. Let&#39;s just say number of rows should always be 3.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)
    <span class="hljs-comment">// 🔴 Value of type &#x27;MenuDataSource&#x27; has no member &#x27;numberOfRows&#x27;;</span>
    <span class="hljs-comment">// did you mean numberOfSections&#x27;?</span>
}
</code></pre>
<p>Once again the simplest way to make the test pass it to hardcode the result to be 3.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfRows</span><span class="hljs-params">(inSection section: Int)</span></span> -&gt; <span class="hljs-type">Int</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>()
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)  <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>Let&#39;s commit this intermediate step. <code>Implement dummy number of rows in section</code>.</p>
<p>Now that we have a green test let&#39;s move to initializing <code>MenuDataSource</code> with an array of pizzas. What&#39;s the least amount of code we can write to achieve it? We always start from the tests:</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>()])
    <span class="hljs-comment">// 🔴 Use of unresolved identifier &#x27;Pizza&#x27;</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-comment">// 🔴 Use of unresolved identifier &#x27;Pizza&#x27;</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)
}
</code></pre>
<p>The compiler is now hinting the next step to us, define <code>Pizza</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pizza</span> </span>{ }
</code></pre>
<p>It&#39;s tempting to add properties to <code>Pizza</code>, like its name, price, and ingredients, but we don&#39;t need that code to make the test pass. The problem we&#39;re trying to solve is not writing a comprehensive <code>Pizza</code>, but making sure we can pass <code>Pizza</code>s to display to <code>MenuDataSource</code>. <strong>TDD is all about solving one very little problem after the other.</strong></p>
<p>If we try to run the tests again we&#39;ll get a new error:</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>()])
    <span class="hljs-comment">// 🔴 Argument passed to call that takes no arguments</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-comment">// 🔴 Argument passed to call that takes no arguments</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)
}
</code></pre>
<p>Let&#39;s pass an array of our new <code>Pizza</code>s as an argument to the <code>init</code> method of <code>MenuDataSource</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuDataSource</span> </span>{

    <span class="hljs-keyword">let</span> pizzas: [<span class="hljs-type">Pizza</span>]
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>)  <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>)  <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>Now the tests are passing again, so let&#39;s commit, even if we haven&#39;t implemented the logic to read the number of <code>Pizza</code>s yet. <code>Pass [Pizza] to MenuDataSource init</code>.</p>
<p><strong>Committing often makes TDD easier</strong>. We move a little bit at a time, and if we end up with something that doesn&#39;t work we only have little code to review. You could even discard those unstaged changes and start from scratch.  Don&#39;t worry about the Git history becoming long, commits are cheap to store. If you want to have a more compact history before your changes are merged you can always <a href="https://thoughtbot.com/blog/git-interactive-rebase-squash-amend-rewriting-history">do an interactive rebase</a> and tidy it up.</p>
<p>Moving on, let&#39;s write the simplest code we can to read make <code>MenuDataSource</code> return a number of rows based on the given <code>[Pizza]</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-comment">// MenuDataSource.swift</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfRows</span><span class="hljs-params">(inSection section: Int)</span></span> -&gt; <span class="hljs-type">Int</span> {
    <span class="hljs-keyword">return</span> pizzas.<span class="hljs-built_in">count</span>
}
</code></pre>
<p>Tests are still green, so our change is a valid implementation of the behaviour. Let&#39;s commit this little change: <code>Return number of menu rows based on input [Pizza]</code>.</p>
<p>What&#39;s our next step? Before moving on to implement the next behaviour let&#39;s look at how we&#39;re testing <code>numberOfRows(inSection:)</code>. Have we considered all its possible behaviours? To answer this question we can look at its input parameter, should the method return the same output for every input? What should it do if the <code>section</code> index provided doesn&#39;t match any of the sections -currently just one- in the menu? Given this method is called &quot;number of rows&quot; a reasonable thing to do would be to return 0. Let&#39;s write a test for this scenario.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInOutOfBoundsSectionIsZero</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">1</span>), <span class="hljs-number">0</span>)
    <span class="hljs-comment">// ❌ XCTAssertEqual failed: (&quot;3&quot;) is not equal to (&quot;0&quot;)</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>)
    <span class="hljs-comment">// ❌ XCTAssertEqual failed: (&quot;3&quot;) is not equal to (&quot;0&quot;)</span>
}
</code></pre>
<p>The tests are failing, you&#39;re not surprised by that are you? The current version of <code>numberOfRows(inSection:)</code> always returns the count of the pizzas. Let&#39;s write as little code as we can to make the tests pass.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfRows</span><span class="hljs-params">(inSection section: Int)</span></span> -&gt; <span class="hljs-type">Int</span> {
    <span class="hljs-keyword">guard</span> section == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> }
    <span class="hljs-keyword">return</span> pizzas.<span class="hljs-built_in">count</span>
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInOutOfBoundsSectionIsZero</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">1</span>), <span class="hljs-number">0</span>)  <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>We made a change and the tests are passing, it&#39;s time to commit: <code>Handle out of bounds sections in numberOfRows(inSection:)</code>.</p>
<p>Next step, make <code>MenuDataSource</code> return what to display for a given a section and row. It&#39;s useful to make the return value a distinct type, let&#39;s call it <code>MenuItem</code>. The reason this is better than returning a <code>Pizza</code> is that it introduces a separation between the domain of the data, pizzas, and the domain of the UI, menu items. This separation allows us to change either of the domains without affecting the other, only the code that converts between the two.</p>
<p>But how can we verify that the <code>MenuItem</code> returned by the method is the one we&#39;re expecting? Or rather, what&#39;s the simplest thing we can do to verify that the <code>MenuItem</code> returned by the method is the expected one? Using pizza name seems like a good candidate for this, if a pizza is named &quot;Margherita&quot; the <code>MenuItem</code> should have <code>title</code> &quot;Margherita&quot; as well.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>) 
    <span class="hljs-comment">// 🔴 Value of type &#x27;MenuDataSource&#x27; has no member &#x27;item&#x27;</span>
}
</code></pre>
<p>The simplest code we can write to make this test pass is having a <code>MenuItem</code> with <code>title</code> that&#39;s always &quot;Margherita&quot;.</p>
<pre><code class=" hljs swift"><span class="hljs-comment">// in MenuItemDataSource.swift</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">item</span><span class="hljs-params">(forRow row: Int, inSection section: Int)</span></span> -&gt; <span class="hljs-type">MenuItem</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-type">MenuItem</span>()
}

<span class="hljs-comment">// in MenuItem.swift</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuItem</span> </span>{

    <span class="hljs-keyword">let</span> title = <span class="hljs-string">&quot;Margherita&quot;</span>
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [<span class="hljs-type">Pizza</span>(), <span class="hljs-type">Pizza</span>()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>)  <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>We have a green test, it&#39;s admittedly incomplete, but still enough for us to have a solid foundation to build upon. Let&#39;s commit it: <code>Implement dummy item(forRow:, inSection:) in MenuDataSource</code>.</p>
<p>Our test is not yet testing the &quot;if a pizza is named &#39;Margherita&#39;&quot; behaviour. To refine our test we need a way to give it <code>Pizza</code>s with different names. It&#39;s time to grow the definition of <code>Pizza</code> with a <code>name</code> property.</p>
<p>Before making the change to the <code>Pizza</code> <code>init</code> and its consumers let&#39;s make the change easy to make. In Kent Beck&#39;s words &quot;make the change easy, warning this might be hard, then make the easy change&quot;.</p>
<p>A way to make the change easier is to reduce number of places in the code where we init <code>Pizza</code> directly. We can do that using a <a href="https://mokacoding.com/blog/streamlining-tests-setup-with-fixtures-in-swift/">fixture extension</a>.</p>
<pre><code class=" hljs swift"><span class="hljs-meta">@testable</span> <span class="hljs-keyword">import</span> Giuseppes

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pizza</span> </span>{

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fixture</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Pizza</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Pizza</span>()
    }
}
</code></pre>
<p>The extension is not doing anything now, but it will make changing the <code>init</code> of <code>Pizza</code> easier because we&#39;ll only have to update the fixture, not all the tests.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture(), .fixture(), .fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInOutOfBoundsSectionIsZero</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture(), .fixture(), .fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture(), .fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>Time to commit, <code>Use fixture extension for Pizza</code>.</p>
<p>Now that we&#39;ve made the change easy, now let&#39;s make the easy change. As always, we start from the tests.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
        <span class="hljs-comment">// 🔴 Argument passed to call that takes no arguments</span>
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>)
}
</code></pre>
<p>The tests are not compiling because <code>Pizza</code> and its fixture don&#39;t have a <code>name</code>. Here you can see how having a fixture makes changing tests easier. By defaulting the <code>name</code> parameter we make it so that all the tests calling <code>.fixture()</code> don&#39;t need to be updated, unless we want to test behaviour depending directly on the value by passing a custom one.</p>
<pre><code class=" hljs swift"><span class="hljs-comment">// Pizza.swift</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Pizza</span> </span>{

    <span class="hljs-keyword">let</span> name: <span class="hljs-type">String</span>
}

<span class="hljs-comment">// Pizza+Fixture.swift</span>
<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">Pizza</span> </span>{

    <span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fixture</span><span class="hljs-params">(name: String = <span class="hljs-string">&quot;Margherita&quot;</span>)</span></span> -&gt; <span class="hljs-type">Pizza</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-type">Pizza</span>(name: name)
    }
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHasOneSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfSections, <span class="hljs-number">1</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture(), .fixture(), .fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">0</span>), <span class="hljs-number">3</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testRowsInOutOfBoundsSectionIsZero</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(pizzas: [.fixture(), .fixture(), .fixture()])
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: <span class="hljs-number">1</span>), <span class="hljs-number">0</span>) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.numberOfRows(inSection: -<span class="hljs-number">1</span>), <span class="hljs-number">0</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>You know what&#39;s next right? Commit: <code>Add name property to Pizza</code>.</p>
<p>This time, rather than replacing the dummy implementation straightaway let&#39;s add another test to prove the code we have right now is incorrect. This technique is called triangulation (even if we&#39;re using only two assertions).</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">1</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Capricciosa&quot;</span>)
    <span class="hljs-comment">// ❌ XCTAssertEqual failed: (&quot;Margherita&quot;) is not equal to (&quot;Capricciosa&quot;)</span>
}
</code></pre>
<p>Let&#39;s write a proper implementation:</p>
<pre><code class=" hljs swift"><span class="hljs-comment">// MenuDataSource.swift</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">item</span><span class="hljs-params">(forRow row: Int, inSection section: Int)</span></span> -&gt; <span class="hljs-type">MenuItem</span> {
   <span class="hljs-keyword">return</span> <span class="hljs-type">MenuItem</span>(pizza: pizzas[row])
}

<span class="hljs-comment">// MenuItem.swift</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MenuItem</span> </span>{

    <span class="hljs-keyword">let</span> title: <span class="hljs-type">String</span>
}

<span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MenuItem</span> </span>{

    <span class="hljs-keyword">init</span>(pizza: <span class="hljs-type">Pizza</span>) {
        <span class="hljs-keyword">self</span>.<span class="hljs-keyword">init</span>(title: pizza.name)
    }
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">1</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Capricciosa&quot;</span>) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>Commit <code>Provide actual implementation for item(forRow:, inSection:)</code></p>
<p>Like we did for <code>numbe of rows</code>, we should ask ourselves whether we&#39;ve covered the behaviour for all the possible kinds of input. What would happen if we gave a section index that doesn&#39;t match? What about a row? Given this method is called &quot;item for row in section&quot; if the row and section pair doesn&#39;t match the backing data then returning &quot;nothing&quot; seems appropriate. Swift&#39;s beautiful <code>Optional</code> type is the best tool to describe this scenario.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForOutOfBoundsRowAndSectionIsNil</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">0</span>))
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">1</span>))
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">1</span>))
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: -<span class="hljs-number">1</span>, inSection: -<span class="hljs-number">1</span>))
}
</code></pre>
<p><img src="https://s3.amazonaws.com/mokacoding/2019-02-07-tdd-28.png" alt="screenshot of tests crashing"></p>
<p>Running the tests now results in a crash, after all we are accessing an out of bounds array. What&#39;s the simplest way we can fix it?</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">item</span><span class="hljs-params">(forRow row: Int, inSection section: Int)</span></span> -&gt; <span class="hljs-type">MenuItem?</span> {
    <span class="hljs-keyword">guard</span> row &gt;= <span class="hljs-number">0</span>, pizzas.<span class="hljs-built_in">count</span> &gt; row <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> .<span class="hljs-keyword">none</span> }
    <span class="hljs-keyword">return</span> <span class="hljs-type">MenuItem</span>(pizza: pizzas[row])
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Margherita&quot;</span>)
    <span class="hljs-comment">// 🔴 Value of optional type &#x27;MenuItem?&#x27; must be unwrapped to refer to member &#x27;title&#x27;</span>
    <span class="hljs-comment">// of wrapped base type &#x27;MenuItem&#x27;</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">1</span>, inSection: <span class="hljs-number">0</span>).title, <span class="hljs-string">&quot;Capricciosa&quot;</span>)
    <span class="hljs-comment">// 🔴 Value of optional type &#x27;MenuItem?&#x27; must be unwrapped to refer to member &#x27;title&#x27;</span>
    <span class="hljs-comment">// of wrapped base type &#x27;MenuItem&#x27;</span>
}
</code></pre>
<p>Notice that this change in the type signature of <code>item(forRow:, inSection:)</code> from <code>-&gt; MenuItem</code> to <code>-&gt; MenuItem?</code> broke the tests. We need to update the other calls to the methods to take into account the new optionality.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForRowAndSection</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">0</span>)?.title, <span class="hljs-string">&quot;Margherita&quot;</span>) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertEqual</span>(dataSource.item(forRow: <span class="hljs-number">1</span>, inSection: <span class="hljs-number">0</span>)?.title, <span class="hljs-string">&quot;Capricciosa&quot;</span>) <span class="hljs-comment">// ✅</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForOutOfBoundsRowAndSectionIsNil</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">0</span>)) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">1</span>))
    <span class="hljs-comment">// ❌ XCTAssertNil failed: &quot;MenuItem(title: &quot;Margherita&quot;)&quot;</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">1</span>)) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: -<span class="hljs-number">1</span>, inSection: -<span class="hljs-number">1</span>)) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>No crash, but still the test for out of bounds section is failing. That&#39;s because in the code above we only checked for the row. Let&#39;s make the check comprehensive.</p>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">item</span><span class="hljs-params">(forRow row: Int, inSection section: Int)</span></span> -&gt; <span class="hljs-type">MenuItem?</span> {
    <span class="hljs-keyword">guard</span> section == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> .<span class="hljs-keyword">none</span> }
    <span class="hljs-keyword">guard</span> row &gt;= <span class="hljs-number">0</span>, pizzas.<span class="hljs-built_in">count</span> &gt; row <span class="hljs-keyword">else</span> { <span class="hljs-keyword">return</span> .<span class="hljs-keyword">none</span> }

    <span class="hljs-keyword">return</span> <span class="hljs-type">MenuItem</span>(pizza: pizzas[row])
}
</code></pre>
<pre><code class=" hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testItemForOutOfBoundsRowAndSectionIsNil</span><span class="hljs-params">()</span></span> {
    <span class="hljs-keyword">let</span> dataSource = <span class="hljs-type">MenuDataSource</span>(
        pizzas: [.fixture(name: <span class="hljs-string">&quot;Margherita&quot;</span>), .fixture(name: <span class="hljs-string">&quot;Capricciosa&quot;</span>)]
    )
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">0</span>)) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">0</span>, inSection: <span class="hljs-number">1</span>)) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: <span class="hljs-number">2</span>, inSection: <span class="hljs-number">1</span>)) <span class="hljs-comment">// ✅</span>
    <span class="hljs-type">XCTAssertNil</span>(dataSource.item(forRow: -<span class="hljs-number">1</span>, inSection: -<span class="hljs-number">1</span>)) <span class="hljs-comment">// ✅</span>
}
</code></pre>
<p>All the tests are now passing, happy days. Commit: <code>Address out of range behaviour of item(forRow:, inSection:)</code>.</p>
<p>We now have a functioning data source for our menu of pizzas. 🎉. The next step would be to feed it into a view controller to show that information to a user. We can of course drive that implementation with tests too, but that&#39;s out of the scope of this post.</p>
<p>Here&#39;s how <code>MenuDataSource</code> can be used to back a <code>UITableView</code>.</p>
<pre><code class=" hljs swift"><span class="hljs-class"><span class="hljs-keyword">extension</span> <span class="hljs-title">MenuViewController</span>: <span class="hljs-title">UITableViewDataSource</span> </span>{

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">numberOfSections</span><span class="hljs-params">(<span class="hljs-keyword">in</span> tableView: UITableView)</span></span> -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> menuDataSource.numberOfSections
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tableView</span><span class="hljs-params">(<span class="hljs-number">_</span> tableView: UITableView, numberOfRowsInSection section: Int)</span></span> -&gt; <span class="hljs-type">Int</span> {
        <span class="hljs-keyword">return</span> menuDataSource.numberOfRows(inSection: section)
    }

    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">tableView</span><span class="hljs-params">(<span class="hljs-number">_</span> tableView: UITableView, cellForRowAt indexPath: IndexPath)</span></span> -&gt; <span class="hljs-type">UITableViewCell</span> {
        <span class="hljs-keyword">let</span> cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, <span class="hljs-keyword">for</span>: indexPath)
        <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> item = menuDataSource.item(forRow: indexPath.row, inSection: indexPath.section) <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> cell
        }

        cell.textLabel?.text = item.title

        <span class="hljs-keyword">return</span> cell
    }
}
</code></pre>
<h2 id="-it-s-too-slow-">&quot;It&#39;s too slow&quot;</h2>
<p>A common observation I get from developers and managers is that TDDing takes longer. <strong>&quot;It would have taken me way less time to write this without tests.&quot;</strong> Sure, it would have. But building a software product is not just a matter of writing code, we also need to make sure the code behaves as expect, and be able to change the code easily.</p>
<p>On top of that, when you have only one screen to work with this might seem like overkill, but most apps don&#39;t have only one screen or one feature do they? For example if we were to add a detail screen for each item in the menu to verify how that screen behaves we would have to always navigate to it. If most of the behaviour is covered by tests we can verify it simply by running the tests, and launch and navigate through the app only when necessary to verify UI details, saving a lot of time.</p>
<p>When driving your implementation with tests you go a bit slower in the writing phase to go faster in all the other steps of the development process. It&#39;s also important to note that as you get more hours of TDD under your belt you&#39;ll get faster at it. The maturity of a test driven codebase helps writing tests faster too, as you&#39;ll have a lot of infrastructure already in place.</p>
<h2 id="recap">Recap</h2>
<p>We&#39;ve seen how to write software driven by tests. The process is simple:</p>
<ul>
<li>Write a test for the code you wish you had, it&#39;ll fail because the code is not there yet.</li>
<li>Use the failing test as feedback to implement just enough code to make the test pass.</li>
<li>Once you have a passing test make the underlying code better.</li>
</ul>
<p>In other words: red, green, commit, refactor, commit.</p>
<p>This simplicity is what makes it powerful. Writing just enough test code to get a failure, then just enough code to make it pass means you&#39;re always solving small problems. This constant and fast feedback loop is a <a href="https://geni.us/StUP">flow</a> inducing process. Like athletes and stand up comedians know well, the faster your feedback loop the faster you&#39;ll improve.</p>
<p><strong>TDD is more than a way to write code, is a business philosophy</strong>. It&#39;s a way to build a product in small incremental steps while continuously getting feedback, from the micro level of a single function, to the macro of an iteration on the next version.</p>
</div><div id="paginator" class="bottom-box clearfixed"><div class="col-6"><div><a href="/blog/wirte-less-code"><<&nbsp;Write Less Code</a></div></div><div class="col-6"><div style="text-align: right"><a href="/blog/the-productivity-project-notes">The Productivity Project - by Chris Bailey&nbsp;>></a></div></div></div><div id="subscribe" class="bottom-box"><!-- Begin Sendfox Signup Form -->
<div id="sendfox_embed_signup">
  <h4 class="form_title">Want more of these posts?</h4>
  <p class="form_caption">Subscribe to receive new posts in your inbox.</p>
  <form method="post" action="https://sendfox.com/form/3ee4z3/10r4wg" class="sendfox-form" id="10r4wg" data-async="true">
    <p><input type="email" placeholder="Email" name="email" class="email" required /></p>
    <!-- no botz please -->
    <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="a_password" tabindex="-1" value="" autocomplete="off" /></div>
    <div class="clear"><button type="submit">Sign me up</button></div>
  </form>
  <script src="https://sendfox.com/js/form.js"></script>
</div>
<!-- End Sendfox Signup Form -->
</div><div class="bottom-box"><div id="disqus_thread"></div><script>var disqus_shortname = "mokacoding";
// Neet do add the / at the end to maintain compatibility with previous version
// of the blog that didn't define disqus_url, letting Disqus set it automatically
// using window.location.href
var disqus_url = "https://mokacoding.com/blog/step-by-step-tdd-in-swift-part-1/";

(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the<a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div></div><div class="row-12 footer"><div class="col-12"><h3><a href="/">mokacoding</a></h3></div><div id="copy" class="col-9"><p>Hi I&#39;m <a href="https://gio.codes">Gio</a> I write here semi-regularly on software testing and TDD, productivity, and iOS development.</p>
<p><a href="mailto:gio+blog@mokacoding.com">Get in touch</a> if you&#39;re interested in working together.</p>
</div><div id="links" class="col-3"><p><i class="fa fa-twitter"></i>&nbsp;<a href="https://twitter.com/mokagio">@mokagio</a></p><p><i class="fa fa-github"></i>&nbsp;<a href="https://github.com/mokagio">mokagio</a></p></div></div></div></body><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-43554041-1', 'auto');
ga('send', 'pageview');
</script><script>var toggle = function(elm){
  var y = elm.style && elm.style.display ? elm.style.display : 'block';
  if (y == 'block'){
    elm.style.opacity='0';
    setTimeout( function(){ elm.style.display = 'none'; }, 300 );
  }
  else {
    elm.style.display='block';
    setTimeout( function(){ elm.style.opacity = '1'; }, 10 );
  }
}

document.getElementById('close').onclick = function(){
  toggle(document.getElementById('sticky-header'));
  toggle(document.getElementById('sticky-header-padding-hack'));
}</script></html>